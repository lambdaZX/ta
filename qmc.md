Алгоритм Квайна-Мак-Класки
===================
Содержание
----------------
[TOC]


Описание алгоритма
--------------------------
Алгоритм Квайна-Мак-Класки ( QMC ) является машинным алгоритмом минимизации функции алгебры логики. Представляет из себя рекурсивный алгоритм. 

Необходимые условия
-----------------------------
> **Для применения алгоритма QMC необходимо выполнение трех условий:**
> 1.  *Разность индексов должна быть равна единице:*
> $$
Id_j  - Id_i = 1.
$$
> 2. *Разность номеров должна быть равна степени двойки:*
> $$Num_j - Num_i = M \  где \   M = 2^n; \   n\in N$$
>3. *Номер с большим индексом были больше номеров с меньшим:*
> $$i<j ⇔ Num_i <Num_j$$


----------

## Входные  данные
Данные заданы в виде строки длинной  **n ( n — степень двойки)**.
Строка отображает некую шкалу (`scale`), элементы (`element`) которой находятся в трех состояниях и показывают :

  
-  '1' — наличие импликанты.
- '0' — отсутствие импликанты.
- '-' — неопределенное состояние.


Пример:

    шкала "1111101-11-10010" длиной n=16

---

> **Дополнительное условие 1 (ДУ1):**
>*Будем рассматривать только те элементы шкалы, которые не равны нулю*     `element != 0`


Для каждого элемента шкалы `!= 0` (в дальнейшем `Implicant`) 
выделим ряд свойств :
> - `Num` - порядковый номер в наборе `от 0 до n-1`.  
> - `Id` — индекс показывает количество единиц в двоично представлении `Num` .  
	Пример: 
$$Num_d=7_d \ ⇒ \ Num_b = 111_b \ ⇒ \ Id = 3$$
> - `P` — путь, расчетная формула будет дана ниже.
> - `Pw` — флаг изменения пути. (`true/false`)
> - `notDef` — флаг неопределенности  (`true/false`), выставляется  в если  `element == '-'`

 Этапы выполнения алгоритма QMC 
---------------------------------------------
Этапы будут рассмотрены  на примере `scale = "1111101-11-10010"`

### Этап 1 (подготовительный этап)
На первом этапе из  шкалы выбираются все импликанты  (*см.  входные  данные, **ДУ1** *).
Для `scale = "1111101-11-10010"` это `element` с номерами {0,1,2,3,4,6,7,8,9,10,11,14}
$$ 
\begin{array}{|l|c|}
\hline \\
 Num & 0&  1 &  2 &  3 & 4 & ! & 6 & 7 & 8 & 9 & 10 & 11 & ! & ! & 14 & !  \\
 \hline \\
 element & 1 & 1 & 1 & 1 & 1 & 0 & 1 & - & 1 & 1 & - & 1 & 0 & 0 &1 & 0  \\
\hline
\end{array}
 $$
 Вычислим для каждого имплеканта Id (*с.м. входные данные, свойства импликант*), для ипликант у которых `element == '-'` значение `Id` приме равным единицы `Id=1`
$$ 
\begin{array}{|l|c|}
\hline \\
 Num & 0&  1 &  2 &  3 & 4 & 6 & 7 & 8 & 9 & 10 & 11  & 14  \\
 \hline \\
 Id  & 0  & 1   &  1  &  2  &  1  &  2  & 3    &  1  &  2  &  2  &  3   & 3   \\ 
\hline
\end{array}
 $$


Выпишем  в таблицу `M1` все найденные свойства импликант, `P, Pw` для всех импликант заполним нулями, а `notDef` для неопределенных импликант зададим 1 (`true`), остальные заполним 0 (`false`):

    element == '-' ? notDef = 1 : notDef = 0

|          |     |     |    |   |   |   |      |   |   |      |    |    |
|:---------|:---:|:---:|:---:|:---:|:---:|:---:|:----:|:---:|:---:|:---:|:----:|:----:|
| **Num**  |  0  |  1  |  2  |  3  |  4  |  6  | 7    |  8  |  9  |  10 |  11  |  14  |
| **Id**   |  0  | 1   |  1  |  2  |  1  |  2  | 3    |  1  |  2  |  2  |  3   |  3   |
| **P**    |  0  | 0   |  0  |  0  |  0  |  0  | 0    |  0  |  0  |  0  |  0   |  0   |
| **Pw**   |  0  | 0   |  0  |  0  |  0  |  0  | 0    |  0  |  0  |  0  |  0   |  0   |
|**notDef**|  0  | 0   |  0  |  0  |  0  |  0  | 1 |  0  |  0  |1 |  0   |  0   |

### Этап 2 (этап вычисления) 
Теперь начинаем этап вычисления. *Цель сформировать таблицу M2* Из таблицы M1 выбираем ипликанты согласно условию.
Напомним :
> **Для применения алгоритма QMC необходимо выполнение трех условий:**
> 1.  *Разность индексов должна быть равна единице:*
> $$
Id_j  - Id_i = 1.
$$
> 2. *Разность номеров должна быть равна степени двойки:*
> $$Num_j - Num_i = M \  где \   M = 2^n; \   n\in N$$
>3. *Номер с большим индексом были больше номеров с меньшим:*
> $$i<j ⇔ Num_i <Num_j$$
>  **+ Добавляется еще одно условие : **
>  4. *Пути должны быть равны:*
>$$P_i=P_j *$$
>
>---
>\* Указано в математической нотации, для программирования `==` 


Каждый импликант из `M1` (начиная с крайнего левого) начинаем сопоставлять с остальными на соответствие условиям.   Если находим соответствие то в то производим   следующие вычисления:  

    if ( Num[j] > Num[i] && <br>  
	     I[j] - I[i] == 1 &&
		 count( N[j] - N[i]) && 
		 P[j] == P[i]
		 
    )

> $$
	Num_{M_2} = N_i ;\\   
	I_{M_2}=I_j; \\  
	P_{M_2} = P_{iM_1} + ( N_j  -N_i); \\
	Pw_{iM_1} = 1; \\
	Pw_{jM_1} = 1;
$$

 



    
